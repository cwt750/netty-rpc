# netty-rpc
项目的实现分为三个模块：
Client+common+server
Common包为clinet包和server包公用的依赖包，里面主要是双方公用的服务组件，分为以下几个部分：第一个是自定义的注解rpcserver，用于标记在服务端具体的服务实现类上；第二个是request和response两个客户端服务端编解码器都要用到的请求类和响应类；第三个是继承了MessageToMessageDecoder的自定义解码器和继承了   MessageToByteEncoder的自定义编码器，这里的自定义编解码方式就用的json序列化和反序列化了，导的是阿里巴巴的fastjson包；然后是一个zookeeper工具类，里面写死了zookeeper的ip+port，通过zkclient获取到对zookeeper的客户端连接，其中规定了两个方法，第一个是register，给服务端用的，服务端的服务会根据服务名和服务地址到zookeeper下面创建节点（其中服务名是持久节点，服务地址是临时节点，做到服务端的动态上下线）；第二个是discover，给客户端用的，客户端会根据服务名称去服务端节点下面找子节点，并且采用随即轮询的方式获取到提供服务的一个子节点。最后就是双方公用的service类接口。

Client包分为nettyclient类，这个类提供了一个client方法，传参为request，通过bootstrap对nettyclient进行初始化，设置socketchannel属性，设置handler，往其中添加添加request类的自定义编码器和response类的自定义解码器以及自定义的Inboundhandler用于返回response，调用zookeeper工具类获取request的对应服务类名称的子节点，通过bootstrap进行连接获取channel，channel.writeandflush(request)，返回response。
Client包还有就是动态代理类，这个类是使用了jdk自带的动态代理实现的。主要创建了一个invocatinhandler的方法，通过构造器注入代理接口类，在重写的invoke方法里面，通过反射获取接口类的方法属性+接口类的传递参数+接口类的类名，通过uuid设置request的序列号，在invoke内部启动nettyclient，并获取到response，返回结果。

Server包主要分为service实现类，这些实现类上都要加上common包里面自定义的rpcserver注解并且标注所属服务的接口类。
然后通过ApplicationContextAware接口编写一个服务自动注册的类，这个类主要的作用是在bean容器注册以后，通过spring上下文获取到注册的bean是否带有的rpcserver的注解，因为rpcserver注解是含有component注解的，因此被rpcserver注解的类会自动生成bean被spring容器托管识别。然后根据获取到的bean所标记的类的名称，以服务所属的接口类名为key，具体的服务实现的bean为value构建成为一个map。然后以自定义的服务主机，服务端口，服务map为传参启动nettyserver。
然后主要是nettyserver启动类，一样通过serverbootstrap启动服务端的设置，设置handler，往其中添加response的自定义编码器和request的自定义解码器以及inboundhandler，inboundhandler会以服务map为传参进行下一步操作。Serverbootstrap会根据服务主机和服务端口进行绑定，开始监听端口，进行连接处理。如果服务端口绑定成功，就遍历服务map，将key值，也就是服务的接口名称作为zookeeper下的持久节点，服务的ip+port作为下面的临时子节点创建节点。
再往下就是具体的inboundhandler处理流程了，通过重写handler中的channelread方法，接收服务端已经反序列化好的request消息。再往下取出request中的一些相关服务信息，比如服务接口名称，以及服务接口的参数，去服务map中找到对应的bean，并且调用bean的具体实现方法得到结果，再取出request的消息序号，包装成response，channel.writeandflush（response）。
